package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"path/filepath"
	"strings"
	"time"
)

const apiHandlerPrefix = "Genx"

type Generator struct {
	gf       *GoFile
	handlers []*ApiHandler
	output   string

	buf bytes.Buffer
}

func NewGenerator(handlers []*ApiHandler) *Generator {
	generator := Generator{
		gf:       handlers[0].gf,
		handlers: handlers,
	}
	return &generator
}

func (g *Generator) printf(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(&g.buf, format, args...)
}

func (g *Generator) Generate() {

	if len(g.handlers) == 0 {
		return
	}

	g.genHead()
	g.genImports()

	for _, handler := range g.handlers {
		g.genHandler(handler)
	}

	src := g.format()
	fileName := g.gf.Name

	outputName := g.output
	if outputName == "" {

		dir := g.gf.GetDir()
		baseName := fmt.Sprintf("%s_genx.go", fileName)
		outputName = filepath.Join(dir, strings.ToLower(baseName))
	}
	err := ioutil.WriteFile(outputName, src, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

func (g *Generator) genHandler(h *ApiHandler) {
	g.printf("\n\n")
	g.printf("func %s%s(ctx *gin.Context) {\n", apiHandlerPrefix, h.Name())

	// declare request params
	if h.requestParam != nil {
		g.printf("\treq := ")
		if h.requestParam.ptr {
			g.printf("&")
		}
		if h.requestParam.pkgName != "" {
			g.printf("%s.", h.requestParam.pkgName)
		}
		g.printf("%s{}\n", h.requestParam.typeName)
	}

	// bind request params
	if h.requestParam != nil {
		g.printf("\t_ = ctx.BindJSON(req)\n")
	}

	// invoke handler
	if h.responseParam != nil {
		g.printf("\tresp ")
	}
	if h.err != nil {
		if h.responseParam != nil {
			g.printf(", ")
		}
		g.printf("err ")
	}
	if h.requestParam != nil || h.err != nil {
		g.printf(":= ")
	}
	g.printf("%s(", h.Name())
	if h.context != nil {
		g.printf("ctx, ")
	}
	if h.requestParam != nil {
		g.printf("req")
	}
	g.printf(")\n")

	if h.err != nil {
		// handle error
		g.printf("\tif err != nil && !ctx.IsAborted() {\n")
		g.printf("\t\tctx.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n")
		g.printf("\t\treturn\n")
		g.printf("\t}\n")
	}

	// return response
	if h.responseParam != nil {
		g.printf("\tif !ctx.IsAborted() {\n")
		g.printf("\t\tctx.JSON(http.StatusOK, resp)\n")
		g.printf("\t}\n")
	}

	g.printf("}\n")
}

func (g *Generator) genHead() {
	g.printf("// Code generated by %s. DO NOT EDIT.\n", "genx api")
	g.printf("// Generated at %s\n", time.Now().Format(time.RFC3339))
	g.printf("\n")
	g.printf("package %s\n\n", g.gf.Pkg.Name)
}

func (g *Generator) genImports() {

	pkgs := map[string]string{}
	for _, handler := range g.handlers {
		handler.getDepImports(pkgs)
	}

	g.printf("import (\n")
	for pkgPath, pkgName := range pkgs {
		if strings.HasSuffix(pkgPath, pkgName) {
			g.printf("\t%q\n", pkgPath)
		} else {
			g.printf("\t%s %q\n", pkgName, pkgPath)
		}
	}
	g.printf("\t\"net/http\"\n")
	g.printf(")\n\n")
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}
